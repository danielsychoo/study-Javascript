# GraphQL-yoga

## GraphQL로 해결할 수 있는 문제들
  1. Over-fetching: 요청에 대해 필요한 data 이상으로 data를 받아와 비효율적인 상황
  2. Under-fetching: 필요한 여러 data를 위해 여러번 요청해야 하는 비효율적인 상황

GraphQL은 두 가지의 특징에서 이러한 부분들을 해결할 수 있음.
  1. 요청을 하는 endpoint가 하나로 되어있음. 따라서 각각의 data를 위해 각각 요청할 필요가 없음.
  2. front에서 직접 query를 작성하여 필요한 정보만 받아올 수 있음.

---

## 환경설정
graphql-yoga의 경우 npm으로 install하면 실행이 안됨 (현재에 한정이고, babel 등 version의 문제로 보임)

### 1) install 진행
```bash
$ mkdir <project명>
$ npm init -y
$ yarn add graphql-yoga
$ npm i -g nodemon
npm i @babel/core @babel/cli @babel/node @babel/preset-env --save-dev
```
### 2) babel preset -> .babelrc
```javascript
{
  "presets": ["@babel/preset-env"]
}
```
### 3) scripts 작성 -> package.json
```javascript
"scripts": {
  "start": "nodemon --exec babel-node index.js",
  ...
}
```
### 4) index.js 작성

---

## Schema
`graphql` dir을 생성하여 해당 dir 내부에 `schema.graphql`, `resolvers.js`를 작성.

### 1) graphql/schema.graphql
  - query에 대한 type등을 지정
  - client단에서 어떤 query를 보내야 할지, 무엇이 필수(isRequired)인지 등 확인 가능.
```graphql
type Query {
  name: String!
}
```

### 2) graphql/resolvers.js
  - `schema.graphql`에서 define한 query에 대한 실제 return data들이 있음.
```javascript
const resolvers = {
  Query: {
    name: () => "daniel", // return 값의 type이 schema와 동일해야 함
  },
};

export default resolvers;
```

### 3) more Useful example
실제 data의 경우 위 예시와 같이 간단하게 되어있는 경우는 없을 것임. 따라서 실제와 같이 예시를 들어보면 아래와 같이 됨.

```graphql
# scheme.graphql

type Daniel { # inner data type
  name: String!,
  age: Int!,
  gender: String!,
}

type Query {
  person: Daniel! # Query에 value로 inner data type 설정
}
```

```javascript
const daniel = { // data source
  name: "daniel",
  age: 32,
  gender: "male",
};

const resolvers = {
  Query: {
    person: () => daniel, // resolve의 value로 data source 연결
  }
}

export default resolvers;
```

이와 같이 schema를 작성해놓으면 client에서는 query를 통해 `person`의 `name`, `age`, `gender`를 취사선택할 수 있음.

```javascript
// person의 age만 필요할 경우
query {
  person {
    age
  }
}
// person의 name, gender만 필요할 경우
query {
  person {
    name
    gender
  }
}
```

이처럼 client단에서 필요한 정보만 뽑아올 수 있다는 장점이 있으나, 반대로 **모든 정보를 가져와야 할 경우에는 query에 모두 작성**해주어야 하는 번거로움 역시 있다.

## GraphQL - Playground
GraphQL로 Server를 구축한 뒤 `yarn start`를 통해 localhost를 열면 `Playground`가 연결됨. 이를 통해 query와 mutation을 테스트해볼 수 있음. MySQL등에서 `Postman`과 대응되는 서비스로 생각할 수 있음.

---

## client에서 schema의 type을 모를경우
아래의 query를 날려 확인 가능
(이외의 부분들도 [공식문서 Introspection](https://graphql.org/learn/introspection/)에서 확인가능)

```javascript
{
  __schema {
    types {
      name
    }
  }
}
```

---



Query: data를 받을 때 사용
Mutation: data를 보낼 때 사용
